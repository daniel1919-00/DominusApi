{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Installation You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and the pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. Optionally set the app namespace, by default it is App , this namespace is also used when creating components for your application (Modules, Controllers, Services, etc.) Configuration You can configure your app behaviour by checking out the configuration docs . Directory Structure A typical Dominus project directory looks something like this: App Modules Controllers Models Migrations Repositories Services Services Middleware Logs Tests Dominus Logs If you have set the APP_LOG_TO_FILE environment variable to 1 then all the logging done by the framework are stored (you can change the location by editing APP_LOG_FILE_LOCATION environment variable ). Tests This is where all your test suites go, and where the testing framework looks for them. Dominus The Dominus framework system files are stored here and should not be modified. Your first module You are now ready to create your first module.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and the pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. Optionally set the app namespace, by default it is App , this namespace is also used when creating components for your application (Modules, Controllers, Services, etc.)","title":"Installation"},{"location":"#configuration","text":"You can configure your app behaviour by checking out the configuration docs .","title":"Configuration"},{"location":"#directory-structure","text":"A typical Dominus project directory looks something like this: App Modules Controllers Models Migrations Repositories Services Services Middleware Logs Tests Dominus","title":"Directory Structure"},{"location":"#logs","text":"If you have set the APP_LOG_TO_FILE environment variable to 1 then all the logging done by the framework are stored (you can change the location by editing APP_LOG_FILE_LOCATION environment variable ).","title":"Logs"},{"location":"#tests","text":"This is where all your test suites go, and where the testing framework looks for them.","title":"Tests"},{"location":"#dominus","text":"The Dominus framework system files are stored here and should not be modified.","title":"Dominus"},{"location":"#your-first-module","text":"You are now ready to create your first module.","title":"Your first module"},{"location":"configuration/","text":"App configuration Startup configuration All the configuration for the Dominus framework is stored in the startup.php file found in the project root. Here you can register global middleware, execute your own boot-up logic and overwrite core functionality like the log function. Check the base class Dominus\\System\\DominusConfiguration to see the different methods that you can override. Environment configuration It is often helpful to have different configuration values based on the environment where your application is running. Dominus uses .env files to achieve this. Custom .env loader Dominus ships with its own .env file loader, but you can always use your own. To achieve this, simply override the public static function loadDotEnv(): void method from the DominusConfiguration base class and load the .env files there, make sure the loaded environment variables are stored in the $_SERVER global variable. Retrieving environment configuration values All the variables listed in the .env file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env function to retrieve values from these variables in your configuration files: 1 2 <?php echo env ( 'APP_NAMESPACE' , 'DefaultNamespace\\\\' ); The second value passed to the env function is the default value. This value will be returned if no environment variable exists for the given key. Dominus configuration The default .env file contains some common configuration values that you may want to change, depending on yor needs, below is a list of the default environment variables and what they represent. General Key Default value Description APP_ENV dev The current running 'mode' of your application. APP_HANDLE_ERRORS 1 Whether the app will automatically log any app errors and disable the default php error handler. Possible values: 0 or 1 APP_LOG_TO_FILE 1 Whether the app should write logs to file (csv). APP_LOG_FILE_LOCATION Path to the directory where the app will write all log csv files. If empty the default path will be used: PROJECT_ROOT/Logs APP_LOG_FILE_NAME_PATTERN dominus-log-{date} The filename pattern used when creating the log files. Possible placeholders: {date} APP_DISPLAY_LOGS 1 Whether to print logged messages. Only works if APP_ENV is set to dev. Possible values: 0 or 1 APP_DISPLAY_LOG_TYPES WARNING,ERROR #Comma separated values. Possible values: INFO, WARNING, ERROR APP_NAMESPACE App\\ #Namespace under which your modules are created. Trailing \\ is required! Database connections Add new connections as DB_(CONNECTION_ALIAS)_* Example: 1 2 3 DB_MY_ALIAS_DSN=\"mysql:host=db;port=3306;dbname=myDatabase\" DB_MY_ALIAS_USERNAME=\"user\" DB_MY_ALIAS_PASSWORD=\"pass\" Key Default value Description DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_(CONNECTION_ALIAS)_PASSWORD Dominus Services Key Default value Description SERVICES_HTTP_CONNECTION_TIMEOUT 30 Maximum number of seconds that the connection can stay open (execution time) SERVICES_HTTP_CONNECT_TIMEOUT 30 The number of seconds to wait while trying to connect. Use 0 to wait indefinitely. SERVICES_HTTP_USERAGENT Dominus API SERVICES_HTTP_SSL_VERIFY_HOST true SERVICES_HTTP_SSL_VERIFY_PEER true Dominus .env loader Dominus ships with a custom-built .env loader with reduced features to focus on loading the .env files as fast as php allows. One feature that is implemented is allowing importing of other .env files, this may be useful if you want to have a common .env base and have the sensitive information in its own separate .env.secrets file for example. Importing other .env files is done by using the @import keyword, followed by a space then the relative path to the .env file you want to import, like so: @import .env.secrets .","title":"App configuration"},{"location":"configuration/#app-configuration","text":"","title":"App configuration"},{"location":"configuration/#startup-configuration","text":"All the configuration for the Dominus framework is stored in the startup.php file found in the project root. Here you can register global middleware, execute your own boot-up logic and overwrite core functionality like the log function. Check the base class Dominus\\System\\DominusConfiguration to see the different methods that you can override.","title":"Startup configuration"},{"location":"configuration/#environment-configuration","text":"It is often helpful to have different configuration values based on the environment where your application is running. Dominus uses .env files to achieve this.","title":"Environment configuration"},{"location":"configuration/#custom-env-loader","text":"Dominus ships with its own .env file loader, but you can always use your own. To achieve this, simply override the public static function loadDotEnv(): void method from the DominusConfiguration base class and load the .env files there, make sure the loaded environment variables are stored in the $_SERVER global variable.","title":"Custom .env loader"},{"location":"configuration/#retrieving-environment-configuration-values","text":"All the variables listed in the .env file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env function to retrieve values from these variables in your configuration files: 1 2 <?php echo env ( 'APP_NAMESPACE' , 'DefaultNamespace\\\\' ); The second value passed to the env function is the default value. This value will be returned if no environment variable exists for the given key.","title":"Retrieving environment configuration values"},{"location":"configuration/#dominus-configuration","text":"The default .env file contains some common configuration values that you may want to change, depending on yor needs, below is a list of the default environment variables and what they represent.","title":"Dominus configuration"},{"location":"configuration/#general","text":"Key Default value Description APP_ENV dev The current running 'mode' of your application. APP_HANDLE_ERRORS 1 Whether the app will automatically log any app errors and disable the default php error handler. Possible values: 0 or 1 APP_LOG_TO_FILE 1 Whether the app should write logs to file (csv). APP_LOG_FILE_LOCATION Path to the directory where the app will write all log csv files. If empty the default path will be used: PROJECT_ROOT/Logs APP_LOG_FILE_NAME_PATTERN dominus-log-{date} The filename pattern used when creating the log files. Possible placeholders: {date} APP_DISPLAY_LOGS 1 Whether to print logged messages. Only works if APP_ENV is set to dev. Possible values: 0 or 1 APP_DISPLAY_LOG_TYPES WARNING,ERROR #Comma separated values. Possible values: INFO, WARNING, ERROR APP_NAMESPACE App\\ #Namespace under which your modules are created. Trailing \\ is required!","title":"General"},{"location":"configuration/#database-connections","text":"Add new connections as DB_(CONNECTION_ALIAS)_* Example: 1 2 3 DB_MY_ALIAS_DSN=\"mysql:host=db;port=3306;dbname=myDatabase\" DB_MY_ALIAS_USERNAME=\"user\" DB_MY_ALIAS_PASSWORD=\"pass\" Key Default value Description DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_(CONNECTION_ALIAS)_PASSWORD","title":"Database connections"},{"location":"configuration/#dominus-services","text":"Key Default value Description SERVICES_HTTP_CONNECTION_TIMEOUT 30 Maximum number of seconds that the connection can stay open (execution time) SERVICES_HTTP_CONNECT_TIMEOUT 30 The number of seconds to wait while trying to connect. Use 0 to wait indefinitely. SERVICES_HTTP_USERAGENT Dominus API SERVICES_HTTP_SSL_VERIFY_HOST true SERVICES_HTTP_SSL_VERIFY_PEER true","title":"Dominus Services"},{"location":"configuration/#dominus-env-loader","text":"Dominus ships with a custom-built .env loader with reduced features to focus on loading the .env files as fast as php allows. One feature that is implemented is allowing importing of other .env files, this may be useful if you want to have a common .env base and have the sensitive information in its own separate .env.secrets file for example. Importing other .env files is done by using the @import keyword, followed by a space then the relative path to the .env file you want to import, like so: @import .env.secrets .","title":"Dominus .env loader"},{"location":"controllers/","text":"Controllers Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers should always be created in your module's Controllers directory. Basic Controllers A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } Controller attributes There are several php attributes that we can use to enhance our controllers and methods. Entrypoint System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by its value if none is provided in the request. RequestMethod System\\Attributes\\RequestMethod This attribute provides a convenient way to limit access on any controller methods to a specific request method (GET, POST, etc.). Middleware System\\Attributes\\Middleware Middleware may be assigned to a controller class as a whole which will be executed everytime the controller is accessed by a request or on specific methods which limits the execution of the middleware only on that method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\Middleware\\UserRolesValidMiddleware ; // This middleware will be called for each request to this controller // and will validate the user's access token. #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { // Additional arguments can be passed to the middleware constructor via the second attribute argument // These can be accessed in the middleware constructor by declaring an argument with the same name as the array key. // In this case the constructor will look something like this: public function __construct(array $requiredRoles) {} #[ Middleware ( UserRolesValidMiddleware :: class , [ 'requiredRoles' => [ 'can-save' , 'administrator' ]])] public function save () { } } See also Handling requests Routing requests Data validation Middleware Dependency Injection","title":"Controllers"},{"location":"controllers/#controllers","text":"Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers should always be created in your module's Controllers directory.","title":"Controllers"},{"location":"controllers/#basic-controllers","text":"A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Basic Controllers"},{"location":"controllers/#controller-attributes","text":"There are several php attributes that we can use to enhance our controllers and methods.","title":"Controller attributes"},{"location":"controllers/#entrypoint","text":"System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by its value if none is provided in the request.","title":"Entrypoint"},{"location":"controllers/#requestmethod","text":"System\\Attributes\\RequestMethod This attribute provides a convenient way to limit access on any controller methods to a specific request method (GET, POST, etc.).","title":"RequestMethod"},{"location":"controllers/#middleware","text":"System\\Attributes\\Middleware Middleware may be assigned to a controller class as a whole which will be executed everytime the controller is accessed by a request or on specific methods which limits the execution of the middleware only on that method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\Middleware\\UserRolesValidMiddleware ; // This middleware will be called for each request to this controller // and will validate the user's access token. #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { // Additional arguments can be passed to the middleware constructor via the second attribute argument // These can be accessed in the middleware constructor by declaring an argument with the same name as the array key. // In this case the constructor will look something like this: public function __construct(array $requiredRoles) {} #[ Middleware ( UserRolesValidMiddleware :: class , [ 'requiredRoles' => [ 'can-save' , 'administrator' ]])] public function save () { } }","title":"Middleware"},{"location":"controllers/#see-also","text":"Handling requests Routing requests Data validation Middleware Dependency Injection","title":"See also"},{"location":"dependency%20injection/","text":"Dependency injection Dominus embraces the dependency injection (DI) software design pattern. Let's take the following controller as an example: 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\MyModule\\Controllers ; #[ Entrypoint ( 'main' )] class TestController extends Controller { #[ RequestMethod ( 'GET' )] public function main ( HttpClient $http ) { } } Here, our controller entrypoint method main depends on the HttpClient service, and will get injected automatically whenever this endpoint is accessed. You can make your own classes compatible with the DI system just by implementing the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. Also, you can further control how your class is injected using one of the following interfaces: * Singleton - Services implementing this interface will have one shared instance * Factory - Implements a factory method to construct your service. Useful when you need instances from a static context, or there are some special arguments that need to be passed to the constructor. Injectable classes can also inject other classes or services without limits, as long as the injected classes implements the necessary Injectable interface. See also Services Middleware Controllers","title":"Dependency injection"},{"location":"dependency%20injection/#dependency-injection","text":"Dominus embraces the dependency injection (DI) software design pattern. Let's take the following controller as an example: 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\MyModule\\Controllers ; #[ Entrypoint ( 'main' )] class TestController extends Controller { #[ RequestMethod ( 'GET' )] public function main ( HttpClient $http ) { } } Here, our controller entrypoint method main depends on the HttpClient service, and will get injected automatically whenever this endpoint is accessed. You can make your own classes compatible with the DI system just by implementing the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. Also, you can further control how your class is injected using one of the following interfaces: * Singleton - Services implementing this interface will have one shared instance * Factory - Implements a factory method to construct your service. Useful when you need instances from a static context, or there are some special arguments that need to be passed to the constructor. Injectable classes can also inject other classes or services without limits, as long as the injected classes implements the necessary Injectable interface.","title":"Dependency injection"},{"location":"dependency%20injection/#see-also","text":"Services Middleware Controllers","title":"See also"},{"location":"middleware/","text":"Middleware Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. Your middleware should reside in the App/Middleware directory of a dominus project. Defining and using a middleware We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { // Middleware also supports dependency injection public function __construct ( private IdentityProvider $idp ) {} /** * Handle the current request. * * @param Request $request * @param mixed $prevMiddlewareRes The data from the middleware that has run before this one. * The value will be NULL if there is no data or this is the first middleware to run. * * @return MiddlewareResolution */ public function handle ( Request $request , mixed $prevMiddlewareRes ) : MiddlewareResolution { $token = $this -> idp -> decodeToken ( $request -> getParam ( 'token' )); if ( ! $token -> isValid ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } // pass along the decoded token to the next middleware return $this -> next ( $token ); } } We can now use middleware on our controller using the #[Middleware] attribute. Using it on the controller will run the middleware for every endpoint. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } Using results from previously run middleware We can use multiple middleware on a controller or controller method, and these will run sequentially passing data between each other in order. Let's take our previous example, where we defined a middleware that helps us validate the user authentication token. We would like to also validate the user roles. We will use the following middleware to check user roles: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserRolesMiddleware extends Middleware { public function __construct ( public array $requiredRoles ) {} /** * Handle the current request. * * @param Request $request * @param mixed $prevMiddlewareRes The data from the middleware that has run before this one. * The value will be NULL if there is no data or this is the first middleware to run. * * @return MiddlewareResolution */ public function handle ( Request $request , mixed $prevMiddlewareRes ) : MiddlewareResolution { /** * We will fetch the decoded token passed along by the previously executed UserTokenValidMiddleware middleware * @var TokenModel $token */ $token = $prevMiddlewareRes ; if ( ! $token -> hasRoles ( $this -> requiredRoles )) { $this -> reject ( httpStatusCode : HttpStatus :: FORBIDDEN ); } return $this -> next (); } } We can now place the middleware on our list endpoint like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { // the second parameter of the Middleware attribute // allows us to pass arguments to the middleware constructor // // Here, for example the array key 'requiredRoles' // will be passed to the constructor's $requiredRoles parameter #[ Middleware ( UserRolesMiddleware :: class , [ 'requiredRoles' => [ 'normal-user' ]])] #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } See also Dependency Injection Services","title":"Middleware"},{"location":"middleware/#middleware","text":"Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. Your middleware should reside in the App/Middleware directory of a dominus project.","title":"Middleware"},{"location":"middleware/#defining-and-using-a-middleware","text":"We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { // Middleware also supports dependency injection public function __construct ( private IdentityProvider $idp ) {} /** * Handle the current request. * * @param Request $request * @param mixed $prevMiddlewareRes The data from the middleware that has run before this one. * The value will be NULL if there is no data or this is the first middleware to run. * * @return MiddlewareResolution */ public function handle ( Request $request , mixed $prevMiddlewareRes ) : MiddlewareResolution { $token = $this -> idp -> decodeToken ( $request -> getParam ( 'token' )); if ( ! $token -> isValid ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } // pass along the decoded token to the next middleware return $this -> next ( $token ); } } We can now use middleware on our controller using the #[Middleware] attribute. Using it on the controller will run the middleware for every endpoint. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Defining and using a middleware"},{"location":"middleware/#using-results-from-previously-run-middleware","text":"We can use multiple middleware on a controller or controller method, and these will run sequentially passing data between each other in order. Let's take our previous example, where we defined a middleware that helps us validate the user authentication token. We would like to also validate the user roles. We will use the following middleware to check user roles: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserRolesMiddleware extends Middleware { public function __construct ( public array $requiredRoles ) {} /** * Handle the current request. * * @param Request $request * @param mixed $prevMiddlewareRes The data from the middleware that has run before this one. * The value will be NULL if there is no data or this is the first middleware to run. * * @return MiddlewareResolution */ public function handle ( Request $request , mixed $prevMiddlewareRes ) : MiddlewareResolution { /** * We will fetch the decoded token passed along by the previously executed UserTokenValidMiddleware middleware * @var TokenModel $token */ $token = $prevMiddlewareRes ; if ( ! $token -> hasRoles ( $this -> requiredRoles )) { $this -> reject ( httpStatusCode : HttpStatus :: FORBIDDEN ); } return $this -> next (); } } We can now place the middleware on our list endpoint like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] #[ Middleware ( UserTokenValidMiddleware :: class )] class TodoListController extends Controller { // the second parameter of the Middleware attribute // allows us to pass arguments to the middleware constructor // // Here, for example the array key 'requiredRoles' // will be passed to the constructor's $requiredRoles parameter #[ Middleware ( UserRolesMiddleware :: class , [ 'requiredRoles' => [ 'normal-user' ]])] #[ RequestMethod ( 'GET' )] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Using results from previously run middleware"},{"location":"middleware/#see-also","text":"Dependency Injection Services","title":"See also"},{"location":"migrations/","text":"Database migrations Database migrations are a way to keep database schemas in sync on all your environments/servers (local, production, stage, etc.). Migration files can also be stored in git, so you always have a sync between your code and databases. All migration operations are done via the migrations.php script. You can check out the available arguments using this command: php migrations.php help . Configuring the database migration system By default, data regarding applied migrations are stored in a plain text file, ideally you would want to store these in a database. To implement your custom migration config, start by making a new class and implement the Dominus\\System\\Interfaces\\MigrationsStorage interface. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 <?php use Dominus\\Services\\Database\\Database ; use Dominus\\System\\Interfaces\\MigrationsStorage ; class MyCustomMigrationsConfig implements MigrationsStorage { private Database $db ; private array $appliedMigrations = []; /** * @throws Exception */ public function __construct () { $this -> db = Database :: getConnection ( 'MIGRATIONS' ); } // In this example we will use a postgresql database /** * @throws Exception */ public function init () : void { $db = $this -> db ; $migrationsTableExists = $db -> query ( \"SELECT EXISTS ( SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'db_migrations' )\" ) -> fetchColumn (); if ( ! $migrationsTableExists ) { $db -> query ( ' CREATE TABLE public.db_migrations ( migration_id text PRIMARY KEY ) ' ); } else { $this -> appliedMigrations = $db -> query ( 'SELECT migration_id FROM public.db_migrations' ) -> fetchAllFromColumn (); } } public function isApplied ( string $migrationId ) : bool { return in_array ( $migrationId , $this -> appliedMigrations ); } public function databaseUpgraded ( string $migrationId ) : void { if ( ! in_array ( $migrationId , $this -> appliedMigrations )) { $this -> appliedMigrations [] = $migrationId ; } } public function databaseDowngraded ( string $migrationId ) : void { foreach ( $this -> appliedMigrations as $idx => $migration ) { if ( $migration == $migrationId ) { unset ( $this -> appliedMigrations [ $idx ]); break ; } } } public function storeMigrations () : void { $db = $this -> db ; $db -> query ( 'TRUNCATE TABLE public.db_migrations' ); $db -> query ( 'INSERT INTO public.db_migrations (migration_id) VALUES ' . implode ( ',' , array_map ( static function ( string $migrationId ) { return \"( $migrationId )\" ; }, $this -> appliedMigrations ))); } } After you have your configuration class, in your startup.php file, make a new static function public static function getMigrationsStorage(): MigrationsStorage that we will use to override the default migrations storage and return our custom storage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php class AppConfiguration extends DominusConfiguration { ... /** * This function will return our custom migrations storage configuration * @return DefaultMigrationsConfig */ public static function getMigrationsStorage () : MigrationsStorage { return new MyCustomMigrationsConfig (); } } Creating a new migration file You can create models using the Dominus CLI using the generate migration command. It will automatically use the namespace of the current Module and create an empty migration file. You can also use the migrations.php file in the Dominus project root(next to index.php ) like so: php my_project/migrations.php add MyModuleDirName . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 <?php class Test1700333087 extends Migration { /** * A list of Modules on which this migration depends on. Example return ['MyModule']; * An empty array should be returned if this migration has no dependencies; * @return string[] */ public function getDependencies () : array { return []; } /** * Apply the migration * @return void */ public function up () { } /** * Revert the migration * @return void */ public function down () { } } Upgrading the database You can upgrade all your modules(that have database migrations) by doing: php migrations.php up If using containers, you can have this command placed in your start script so that your container database is always up-to-date with the code. Downgrading the database You can downgrade by calling the migrations.php with the down argument and pass the migration ID (The filename without its extension, e.g. Test1700333087.php -> Test1700333087).","title":"Database migrations"},{"location":"migrations/#database-migrations","text":"Database migrations are a way to keep database schemas in sync on all your environments/servers (local, production, stage, etc.). Migration files can also be stored in git, so you always have a sync between your code and databases. All migration operations are done via the migrations.php script. You can check out the available arguments using this command: php migrations.php help .","title":"Database migrations"},{"location":"migrations/#configuring-the-database-migration-system","text":"By default, data regarding applied migrations are stored in a plain text file, ideally you would want to store these in a database. To implement your custom migration config, start by making a new class and implement the Dominus\\System\\Interfaces\\MigrationsStorage interface. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 <?php use Dominus\\Services\\Database\\Database ; use Dominus\\System\\Interfaces\\MigrationsStorage ; class MyCustomMigrationsConfig implements MigrationsStorage { private Database $db ; private array $appliedMigrations = []; /** * @throws Exception */ public function __construct () { $this -> db = Database :: getConnection ( 'MIGRATIONS' ); } // In this example we will use a postgresql database /** * @throws Exception */ public function init () : void { $db = $this -> db ; $migrationsTableExists = $db -> query ( \"SELECT EXISTS ( SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'db_migrations' )\" ) -> fetchColumn (); if ( ! $migrationsTableExists ) { $db -> query ( ' CREATE TABLE public.db_migrations ( migration_id text PRIMARY KEY ) ' ); } else { $this -> appliedMigrations = $db -> query ( 'SELECT migration_id FROM public.db_migrations' ) -> fetchAllFromColumn (); } } public function isApplied ( string $migrationId ) : bool { return in_array ( $migrationId , $this -> appliedMigrations ); } public function databaseUpgraded ( string $migrationId ) : void { if ( ! in_array ( $migrationId , $this -> appliedMigrations )) { $this -> appliedMigrations [] = $migrationId ; } } public function databaseDowngraded ( string $migrationId ) : void { foreach ( $this -> appliedMigrations as $idx => $migration ) { if ( $migration == $migrationId ) { unset ( $this -> appliedMigrations [ $idx ]); break ; } } } public function storeMigrations () : void { $db = $this -> db ; $db -> query ( 'TRUNCATE TABLE public.db_migrations' ); $db -> query ( 'INSERT INTO public.db_migrations (migration_id) VALUES ' . implode ( ',' , array_map ( static function ( string $migrationId ) { return \"( $migrationId )\" ; }, $this -> appliedMigrations ))); } } After you have your configuration class, in your startup.php file, make a new static function public static function getMigrationsStorage(): MigrationsStorage that we will use to override the default migrations storage and return our custom storage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php class AppConfiguration extends DominusConfiguration { ... /** * This function will return our custom migrations storage configuration * @return DefaultMigrationsConfig */ public static function getMigrationsStorage () : MigrationsStorage { return new MyCustomMigrationsConfig (); } }","title":"Configuring the database migration system"},{"location":"migrations/#creating-a-new-migration-file","text":"You can create models using the Dominus CLI using the generate migration command. It will automatically use the namespace of the current Module and create an empty migration file. You can also use the migrations.php file in the Dominus project root(next to index.php ) like so: php my_project/migrations.php add MyModuleDirName . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 <?php class Test1700333087 extends Migration { /** * A list of Modules on which this migration depends on. Example return ['MyModule']; * An empty array should be returned if this migration has no dependencies; * @return string[] */ public function getDependencies () : array { return []; } /** * Apply the migration * @return void */ public function up () { } /** * Revert the migration * @return void */ public function down () { } }","title":"Creating a new migration file"},{"location":"migrations/#upgrading-the-database","text":"You can upgrade all your modules(that have database migrations) by doing: php migrations.php up If using containers, you can have this command placed in your start script so that your container database is always up-to-date with the code.","title":"Upgrading the database"},{"location":"migrations/#downgrading-the-database","text":"You can downgrade by calling the migrations.php with the down argument and pass the migration ID (The filename without its extension, e.g. Test1700333087.php -> Test1700333087).","title":"Downgrading the database"},{"location":"models/","text":"Data models You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[ Optional ] public string $optionalProp = '' ; } Model attributes Optional Used to mark model properties as optional, when handling requests using data models. The framework will try and find each property name in the Request object, and will throw an Exception if the property is not found and not marked as optional. InitModel Used to declare any method inside a model to be used for initialization. This method will be called immediately after the Request object data has been mapped to the model properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; use Dominus\\System\\Attributes\\InitModel ; #[ InitModel ( 'init' )] class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[ Optional ] public string $optionalProp = '' ; public function init () { // this method will be called immediately after the properties have been // mapped from the Request object } } See also Handling Requests","title":"Data models"},{"location":"models/#data-models","text":"You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[ Optional ] public string $optionalProp = '' ; }","title":"Data models"},{"location":"models/#model-attributes","text":"","title":"Model attributes"},{"location":"models/#optional","text":"Used to mark model properties as optional, when handling requests using data models. The framework will try and find each property name in the Request object, and will throw an Exception if the property is not found and not marked as optional.","title":"Optional"},{"location":"models/#initmodel","text":"Used to declare any method inside a model to be used for initialization. This method will be called immediately after the Request object data has been mapped to the model properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; use Dominus\\System\\Attributes\\InitModel ; #[ InitModel ( 'init' )] class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[ Optional ] public string $optionalProp = '' ; public function init () { // this method will be called immediately after the properties have been // mapped from the Request object } }","title":"InitModel"},{"location":"models/#see-also","text":"Handling Requests","title":"See also"},{"location":"modules/","text":"Modules Dominus applications are modular, these modules are containers for Controllers, Models, and everything else related to a particular module. Modules reside in the App/Modules directory of a dominus project. You can generate modules with the command generate module MyModule See also Controllers","title":"Modules"},{"location":"modules/#modules","text":"Dominus applications are modular, these modules are containers for Controllers, Models, and everything else related to a particular module. Modules reside in the App/Modules directory of a dominus project. You can generate modules with the command generate module MyModule","title":"Modules"},{"location":"modules/#see-also","text":"Controllers","title":"See also"},{"location":"repositories/","text":"Repository pattern The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } } See also Dependency Injection","title":"Repository pattern"},{"location":"repositories/#repository-pattern","text":"The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } }","title":"Repository pattern"},{"location":"repositories/#see-also","text":"Dependency Injection","title":"See also"},{"location":"request/","text":"Request The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application. Usage To access the request object, inject it by setting it as an argument to your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\TodoList\\Controllers ; class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } } Using data models to handle requests Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use App\\Modules\\TodoList\\Models\\FormDataModel ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\DataModel\\Validate ; use Dominus\\System\\Attributes\\DataModel\\Optional ; class FormDataModel { public int $id = 0 ; #[ Validate ( 'max_length:255' )] public string $description = '' ; #[ Validate ( 'date' )] public DateTime | null $completedOn = null ; #[ Optional ] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. You can also use the #[validate()] attribute to apply validation rules to the properties. See also Data validation","title":"Request"},{"location":"request/#request","text":"The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application.","title":"Request"},{"location":"request/#usage","text":"To access the request object, inject it by setting it as an argument to your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\TodoList\\Controllers ; class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } }","title":"Usage"},{"location":"request/#using-data-models-to-handle-requests","text":"Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use App\\Modules\\TodoList\\Models\\FormDataModel ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\DataModel\\Validate ; use Dominus\\System\\Attributes\\DataModel\\Optional ; class FormDataModel { public int $id = 0 ; #[ Validate ( 'max_length:255' )] public string $description = '' ; #[ Validate ( 'date' )] public DateTime | null $completedOn = null ; #[ Optional ] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. You can also use the #[validate()] attribute to apply validation rules to the properties.","title":"Using data models to handle requests"},{"location":"request/#see-also","text":"Data validation","title":"See also"},{"location":"routing/","text":"Routing Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/App/Modules/Mymodule/Controllers/MyController Basic route 1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase Route Shortcuts Module has the same name as the controller If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module Controller has an Entrypoint attribute set If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller See also Modules Controllers","title":"Routing"},{"location":"routing/#routing","text":"Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/App/Modules/Mymodule/Controllers/MyController","title":"Routing"},{"location":"routing/#basic-route","text":"1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase","title":"Basic route"},{"location":"routing/#route-shortcuts","text":"","title":"Route Shortcuts"},{"location":"routing/#module-has-the-same-name-as-the-controller","text":"If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module","title":"Module has the same name as the controller"},{"location":"routing/#controller-has-an-entrypoint-attribute-set","text":"If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller","title":"Controller has an Entrypoint attribute set"},{"location":"routing/#see-also","text":"Modules Controllers","title":"See also"},{"location":"services/","text":"Services A service in Dominus is really any class that implements the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. Your services should reside in the App/Services directory of a Dominus project. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace Dominus\\Services ; use Dominus\\System\\Interfaces\\Injectable\\Injectable ; class MyServiceService implements Injectable { public function __construct () { } } See also Dependency Injection Middleware","title":"Services"},{"location":"services/#services","text":"A service in Dominus is really any class that implements the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. Your services should reside in the App/Services directory of a Dominus project. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace Dominus\\Services ; use Dominus\\System\\Interfaces\\Injectable\\Injectable ; class MyServiceService implements Injectable { public function __construct () { } }","title":"Services"},{"location":"services/#see-also","text":"Dependency Injection Middleware","title":"See also"},{"location":"unit%20testing/","text":"Unit testing Dominus comes with its own little testing framework, which can be used to run simple unit tests. You can generate tests easily using the dominus cli with the command generate test MyTest . To create a unit test we begin by creating a new Test suite class in the Tests directory of a Dominus project, you can also create any number of subdirectories if you want to group your test suites further and the framework will scan for them recursively. Make sure your filename is the same as your class name! Our test suite class must extend the Dominus\\System\\Tests\\DominusTest base class. 1 2 3 4 5 6 7 8 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; class MyTest extends DominusTest { } We will use the Dominus\\System\\Attributes\\TestName attribute to name our test suite something accordingly. The same attribute can be used to name your test cases if placed on the class method. 1 2 3 4 5 6 7 8 9 10 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { } Now, we can create our individual test cases. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 1' )] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 2' )] public function test_case_2 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } Finally, we need to return the test instance so that the test framework can use it; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 1' )] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } return new MyTest (); Now all that remains is to actually run our tests, to do this you can execute the run_tests.php file in the Dominus project root.","title":"Unit testing"},{"location":"unit%20testing/#unit-testing","text":"Dominus comes with its own little testing framework, which can be used to run simple unit tests. You can generate tests easily using the dominus cli with the command generate test MyTest . To create a unit test we begin by creating a new Test suite class in the Tests directory of a Dominus project, you can also create any number of subdirectories if you want to group your test suites further and the framework will scan for them recursively. Make sure your filename is the same as your class name! Our test suite class must extend the Dominus\\System\\Tests\\DominusTest base class. 1 2 3 4 5 6 7 8 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; class MyTest extends DominusTest { } We will use the Dominus\\System\\Attributes\\TestName attribute to name our test suite something accordingly. The same attribute can be used to name your test cases if placed on the class method. 1 2 3 4 5 6 7 8 9 10 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { } Now, we can create our individual test cases. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 1' )] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 2' )] public function test_case_2 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } Finally, we need to return the test instance so that the test framework can use it; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestName ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[ TestName ( 'My test suite name' )] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[ TestRequestParameters ([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[ TestName ( 'My test case 1' )] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } return new MyTest (); Now all that remains is to actually run our tests, to do this you can execute the run_tests.php file in the Dominus project root.","title":"Unit testing"},{"location":"validation/","text":"Data Validation Incoming data is always automatically validated based on the endpoint parameters if any. Auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer. Take the following controller code that handles logic for a simple todo app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () {} // retrieves the todo items public function add () {} // adds items to the list } To validate our todo entries, we will use the Dominus\\Services\\Validator service to help us. We start by injecting the Dominus\\Services\\Validator service in our add method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 <?php $invalidFields = $validator -> validate ( $data , [ 'request_field' => 'date|date_after:tomorrow' ]); Multiple rules on the same field are run in order and throws an exception to the first rule that has an error (to prevent this set the ->validate method $bailOnFirstError argument to false). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <?php namespace App\\Modules\\TodoList\\Controllers ; use App\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function add ( FormDataModel $data , Validator $validator ) { // If the 3rd parameter is set to false then $validator->validate // throws an exception instead of returning an array of fields that failed 1 or more rules $invalidFields = $validator -> validate ( $data , [ 'title' => 'min_length:3|max_length:120' , 'description' => 'max_length:255' , 'completedOn' => 'nullable|date' ]); if ( $invalidFields ) { // $invalidFields contains the fields that did not pass validation and the corresponding rules that failed. // For example, if the description is too long, we will have: ['description' => ['max_length']] var_dump ( $invalidFields ); } } } Data model validation You can also validate data model properties when they are mapped from the Request object. Let's take our FormDataModel from the previous example and setup some validation for its properties: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\DataModel\\Validate ; use Dominus\\System\\Attributes\\DataModel\\Optional ; class FormDataModel { #[ Validate ( 'min_length:3|max_length:120' )] public string $title ; #[ Validate ( 'max_length:255' )] public string $desription ; #[ Optional ] #[ Validate ( 'date' )] public ? DateTimeImmutable $completedOn ; } Available validation rules Below is a list of all the available validation rules. Rules are separated using the pipe character | Rule arguments are separated by a semicolon: : . Example: min_length:5|max_length:200 min_length max_length in_list not_in_list true not_equals equals required email date date_equals date_after date_after_or_equal date_before date_before_or_equal min_length min_length:[length] Verifies that the field string length is greater than or equal to the given length. Positional Arguments: * [Required] the minimum length. Example: min_length:10 max_length max_length:[length] Verifies that the field string length is less than or equal to the given length. Positional Arguments: * [Required] the maximum length. Example: min_length:200 in_list in_list:comma, separated, items Verifies that the field value is contained in the given list. Positional Arguments: * [Required] A list of items to check the validated field against. Example: in_list:item1, item2, item3 not_in_list not_in_list:comma, separated, items Verifies that the field value is not contained in the given list. Positional Arguments: * [Required] A list of items to check the validated field against. Example: in_list:item1, item2, item3 is_true is_true Verifies that the field value has a true boolean value. is_false is_false Verifies that the field value has a false boolean value. equals equals:[value] Verifies that the field value equals the provided static value. Positional Arguments: * [Required] The value to check the validated field against. Example: equals:27 not_equals not_equals:[value] Verifies that the field value does not equal the provided static value. Positional Arguments: * [Required] The value to check the validated field against. Example: not_equals:27 email email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator. required required Verifies that the field exists and is not empty. date date:[format] The validated field value will be verified by using the PHP strtotime function. Positional Arguments: * [Optional] format to validate against. Example: date:Y-m-d date_equals date_equals:[datetime]:[format] The validated field must be equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_equals:+2 days * [Optional] compares the dates using the given date format. Example: date_equals:+2 days:Y-m-d H\\:i date_after date_after:[datetime] The validated field must be a value after the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_after:now date_after_or_equal date_after_or_equal:[datetime] The validated field must be a value after or equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_after_or_equal:2027-06-07 date_before date_before:[datetime] The validated field must be a value preceding the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_before:2002-06-07 date_before_or_equal date_before_or_equal:[datetime] The validated field must be a value preceding or equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_before_or_equal:2002-06-07 See also Handling requests Data models","title":"Data Validation"},{"location":"validation/#data-validation","text":"Incoming data is always automatically validated based on the endpoint parameters if any. Auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer. Take the following controller code that handles logic for a simple todo app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\RequestMethod ; #[ Entrypoint ( 'list' )] class TodoListController extends Controller { #[ RequestMethod ( 'GET' )] public function list () {} // retrieves the todo items public function add () {} // adds items to the list } To validate our todo entries, we will use the Dominus\\Services\\Validator service to help us. We start by injecting the Dominus\\Services\\Validator service in our add method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 <?php $invalidFields = $validator -> validate ( $data , [ 'request_field' => 'date|date_after:tomorrow' ]); Multiple rules on the same field are run in order and throws an exception to the first rule that has an error (to prevent this set the ->validate method $bailOnFirstError argument to false). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <?php namespace App\\Modules\\TodoList\\Controllers ; use App\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function add ( FormDataModel $data , Validator $validator ) { // If the 3rd parameter is set to false then $validator->validate // throws an exception instead of returning an array of fields that failed 1 or more rules $invalidFields = $validator -> validate ( $data , [ 'title' => 'min_length:3|max_length:120' , 'description' => 'max_length:255' , 'completedOn' => 'nullable|date' ]); if ( $invalidFields ) { // $invalidFields contains the fields that did not pass validation and the corresponding rules that failed. // For example, if the description is too long, we will have: ['description' => ['max_length']] var_dump ( $invalidFields ); } } }","title":"Data Validation"},{"location":"validation/#data-model-validation","text":"You can also validate data model properties when they are mapped from the Request object. Let's take our FormDataModel from the previous example and setup some validation for its properties: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\DataModel\\Validate ; use Dominus\\System\\Attributes\\DataModel\\Optional ; class FormDataModel { #[ Validate ( 'min_length:3|max_length:120' )] public string $title ; #[ Validate ( 'max_length:255' )] public string $desription ; #[ Optional ] #[ Validate ( 'date' )] public ? DateTimeImmutable $completedOn ; }","title":"Data model validation"},{"location":"validation/#available-validation-rules","text":"Below is a list of all the available validation rules. Rules are separated using the pipe character | Rule arguments are separated by a semicolon: : . Example: min_length:5|max_length:200 min_length max_length in_list not_in_list true not_equals equals required email date date_equals date_after date_after_or_equal date_before date_before_or_equal","title":"Available validation rules"},{"location":"validation/#min_length","text":"min_length:[length] Verifies that the field string length is greater than or equal to the given length. Positional Arguments: * [Required] the minimum length. Example: min_length:10","title":"min_length"},{"location":"validation/#max_length","text":"max_length:[length] Verifies that the field string length is less than or equal to the given length. Positional Arguments: * [Required] the maximum length. Example: min_length:200","title":"max_length"},{"location":"validation/#in_list","text":"in_list:comma, separated, items Verifies that the field value is contained in the given list. Positional Arguments: * [Required] A list of items to check the validated field against. Example: in_list:item1, item2, item3","title":"in_list"},{"location":"validation/#not_in_list","text":"not_in_list:comma, separated, items Verifies that the field value is not contained in the given list. Positional Arguments: * [Required] A list of items to check the validated field against. Example: in_list:item1, item2, item3","title":"not_in_list"},{"location":"validation/#is_true","text":"is_true Verifies that the field value has a true boolean value.","title":"is_true"},{"location":"validation/#is_false","text":"is_false Verifies that the field value has a false boolean value.","title":"is_false"},{"location":"validation/#equals","text":"equals:[value] Verifies that the field value equals the provided static value. Positional Arguments: * [Required] The value to check the validated field against. Example: equals:27","title":"equals"},{"location":"validation/#not_equals","text":"not_equals:[value] Verifies that the field value does not equal the provided static value. Positional Arguments: * [Required] The value to check the validated field against. Example: not_equals:27","title":"not_equals"},{"location":"validation/#email","text":"email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator.","title":"email"},{"location":"validation/#required","text":"required Verifies that the field exists and is not empty.","title":"required"},{"location":"validation/#date","text":"date:[format] The validated field value will be verified by using the PHP strtotime function. Positional Arguments: * [Optional] format to validate against. Example: date:Y-m-d","title":"date"},{"location":"validation/#date_equals","text":"date_equals:[datetime]:[format] The validated field must be equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_equals:+2 days * [Optional] compares the dates using the given date format. Example: date_equals:+2 days:Y-m-d H\\:i","title":"date_equals"},{"location":"validation/#date_after","text":"date_after:[datetime] The validated field must be a value after the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_after:now","title":"date_after"},{"location":"validation/#date_after_or_equal","text":"date_after_or_equal:[datetime] The validated field must be a value after or equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_after_or_equal:2027-06-07","title":"date_after_or_equal"},{"location":"validation/#date_before","text":"date_before:[datetime] The validated field must be a value preceding the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_before:2002-06-07","title":"date_before"},{"location":"validation/#date_before_or_equal","text":"date_before_or_equal:[datetime] The validated field must be a value preceding or equal to the given date. The dates will be parsed and validated by the PHP strtotime function. Positional Arguments: * [Optional] a string that can be parsed by the PHP strtotime function. Example: date_before_or_equal:2002-06-07","title":"date_before_or_equal"},{"location":"validation/#see-also","text":"Handling requests Data models","title":"See also"}]}