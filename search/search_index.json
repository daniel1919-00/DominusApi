{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Installation You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. Optionally set the app namespace, by default it is App , this namespace is also used when creating components for your application (Modules, Controllers, Services, etc.) You are now ready to create your first module. Directory Structure Dominus project directory App Modules Controllers Models Middleware Repositories Services Middleware Services Logs Dominus Logs Framework logs as well as php logs are stored here as .csv files with the current date (Y-m-d) as the filename. Dominus The Dominus framework system files are stored here and should not be modified.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. Optionally set the app namespace, by default it is App , this namespace is also used when creating components for your application (Modules, Controllers, Services, etc.) You are now ready to create your first module.","title":"Installation"},{"location":"#directory-structure","text":"Dominus project directory App Modules Controllers Models Middleware Repositories Services Middleware Services Logs Dominus","title":"Directory Structure"},{"location":"#logs","text":"Framework logs as well as php logs are stored here as .csv files with the current date (Y-m-d) as the filename.","title":"Logs"},{"location":"#dominus","text":"The Dominus framework system files are stored here and should not be modified.","title":"Dominus"},{"location":"controllers/","text":"Controllers Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers should always be created in your module's Controllers directory. Basic Controllers A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } Controller attributes There are several php attributes that we can use to enhance our controllers and methods. Entrypoint System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by its value if none is provided in the request. RequestMethod System\\Attributes\\RequestMethod This attribute provides a convenient way to limit access on any controller methods to a specific request method (GET, POST, etc.). Middleware System\\Attributes\\Middleware Middleware may be assigned to a controller class as a whole which will be executed everytime the controller is accessed by a request or on specific methods which limits the execution of the middleware only on that method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\Middleware\\UserRolesValidMiddleware ; // This middleware will be called for each request to this controller // and will validate the user's access token. #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { // Additional arguments can be passed to the middleware constructor via the second attribute argument // These can be accessed in the middleware constructor by declaring an argument with the same name as the array key. // In this case the constructor will look something like this: public function __construct(array $requiredRoles) {} #[Middleware(UserRolesValidMiddleware::class, ['requiredRoles' => ['can-save', 'administrator']])] public function save () { } } See also Handling requests Routing requests Data validation Middleware Dependency Injection","title":"Controllers"},{"location":"controllers/#controllers","text":"Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers should always be created in your module's Controllers directory.","title":"Controllers"},{"location":"controllers/#basic-controllers","text":"A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Basic Controllers"},{"location":"controllers/#controller-attributes","text":"There are several php attributes that we can use to enhance our controllers and methods.","title":"Controller attributes"},{"location":"controllers/#entrypoint","text":"System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by its value if none is provided in the request.","title":"Entrypoint"},{"location":"controllers/#requestmethod","text":"System\\Attributes\\RequestMethod This attribute provides a convenient way to limit access on any controller methods to a specific request method (GET, POST, etc.).","title":"RequestMethod"},{"location":"controllers/#middleware","text":"System\\Attributes\\Middleware Middleware may be assigned to a controller class as a whole which will be executed everytime the controller is accessed by a request or on specific methods which limits the execution of the middleware only on that method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\Middleware\\UserRolesValidMiddleware ; // This middleware will be called for each request to this controller // and will validate the user's access token. #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { // Additional arguments can be passed to the middleware constructor via the second attribute argument // These can be accessed in the middleware constructor by declaring an argument with the same name as the array key. // In this case the constructor will look something like this: public function __construct(array $requiredRoles) {} #[Middleware(UserRolesValidMiddleware::class, ['requiredRoles' => ['can-save', 'administrator']])] public function save () { } }","title":"Middleware"},{"location":"controllers/#see-also","text":"Handling requests Routing requests Data validation Middleware Dependency Injection","title":"See also"},{"location":"dependency%20injection/","text":"Dependency injection Dominus supports the dependency injection (DI) software design pattern. Let's take the following controller as an example: 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\MyModule\\Controllers ; #[Entrypoint('main')] class TestController extends Controller { #[RequestMethod('GET')] public function main ( HttpClient $http ) { } } Here, our controller depends on the HttpClient service, and is injected dynamically into the main method that has been marked as an entrypoint. Essentially each request that to this method will have the HttpClient class instantiated and injected into the method as an argument. You can make your own classes compatible with the DI system just by implementing the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. Also, you can further control how your class is injected using one of the following interfaces: * Singleton - Services implementing this interface will have one shared instance * Factory - Implements a factory method to construct your service. Useful when you need instances from a static context, or there are some special arguments that need to be passed to the constructor. Injectable classes can also inject other classes or services without limits, as long as the injected classes implements the necessary Injectable interface. See also Services Middleware Controllers","title":"Dependency injection"},{"location":"dependency%20injection/#dependency-injection","text":"Dominus supports the dependency injection (DI) software design pattern. Let's take the following controller as an example: 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\MyModule\\Controllers ; #[Entrypoint('main')] class TestController extends Controller { #[RequestMethod('GET')] public function main ( HttpClient $http ) { } } Here, our controller depends on the HttpClient service, and is injected dynamically into the main method that has been marked as an entrypoint. Essentially each request that to this method will have the HttpClient class instantiated and injected into the method as an argument. You can make your own classes compatible with the DI system just by implementing the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. Also, you can further control how your class is injected using one of the following interfaces: * Singleton - Services implementing this interface will have one shared instance * Factory - Implements a factory method to construct your service. Useful when you need instances from a static context, or there are some special arguments that need to be passed to the constructor. Injectable classes can also inject other classes or services without limits, as long as the injected classes implements the necessary Injectable interface.","title":"Dependency injection"},{"location":"dependency%20injection/#see-also","text":"Services Middleware Controllers","title":"See also"},{"location":"environment%20configuration/","text":"Environment configuration It is often helpful to have different configuration values based on the environment where your application is running. Dominus uses .env files to achieve this. Retrieving environment configuration values All the variables listed in the .env file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env function to retrieve values from these variables in your configuration files: 1 2 <?php echo env ( 'APP_NAMESPACE' , 'DefaultNamespace\\\\' ); The second value passed to the env function is the default value. This value will be returned if no environment variable exists for the given key. Dominus configuration The default .env file contains some common configuration values that you may want to change, depending on yor needs, below is a list of the default environment variables and what they represent. General Key Default value Description APP_ENV dev The current running 'mode' of your application. APP_DISPLAY_LOGS 1 Whether to print logged messages. Only works if APP_ENV is set to dev. Possible values: 0 or 1 APP_DISPLAY_LOG_TYPES WARNING,ERROR #Comma separated values. Possible values: INFO, WARNING, ERROR DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_DEFAULT_PASSWORD Database connections Add new connections as DB_(CONNECTION_ALIAS)_* Example: 1 2 3 DB_MY_ALIAS_DSN=\"mysql:host=db;port=3306;dbname=myDatabase\" DB_MY_ALIAS_USERNAME=\"user\" DB_MY_ALIAS_PASSWORD=\"pass\" Key Default value Description DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_(CONNECTION_ALIAS)_PASSWORD Dominus Services Key Default value Description SERVICES_HTTP_CONNECTION_TIMEOUT 30 Maximum number of seconds that the connection can stay open (execution time) SERVICES_HTTP_CONNECT_TIMEOUT 30 The number of seconds to wait while trying to connect. Use 0 to wait indefinitely. SERVICES_HTTP_USERAGENT Dominus API SERVICES_HTTP_SSL_VERIFY_HOST true SERVICES_HTTP_SSL_VERIFY_PEER true","title":"Environment configuration"},{"location":"environment%20configuration/#environment-configuration","text":"It is often helpful to have different configuration values based on the environment where your application is running. Dominus uses .env files to achieve this.","title":"Environment configuration"},{"location":"environment%20configuration/#retrieving-environment-configuration-values","text":"All the variables listed in the .env file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env function to retrieve values from these variables in your configuration files: 1 2 <?php echo env ( 'APP_NAMESPACE' , 'DefaultNamespace\\\\' ); The second value passed to the env function is the default value. This value will be returned if no environment variable exists for the given key.","title":"Retrieving environment configuration values"},{"location":"environment%20configuration/#dominus-configuration","text":"The default .env file contains some common configuration values that you may want to change, depending on yor needs, below is a list of the default environment variables and what they represent.","title":"Dominus configuration"},{"location":"environment%20configuration/#general","text":"Key Default value Description APP_ENV dev The current running 'mode' of your application. APP_DISPLAY_LOGS 1 Whether to print logged messages. Only works if APP_ENV is set to dev. Possible values: 0 or 1 APP_DISPLAY_LOG_TYPES WARNING,ERROR #Comma separated values. Possible values: INFO, WARNING, ERROR DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_DEFAULT_PASSWORD","title":"General"},{"location":"environment%20configuration/#database-connections","text":"Add new connections as DB_(CONNECTION_ALIAS)_* Example: 1 2 3 DB_MY_ALIAS_DSN=\"mysql:host=db;port=3306;dbname=myDatabase\" DB_MY_ALIAS_USERNAME=\"user\" DB_MY_ALIAS_PASSWORD=\"pass\" Key Default value Description DB_(CONNECTION_ALIAS)_DSN DSN used for this connection alias DB_(CONNECTION_ALIAS)_USERNAME DB_(CONNECTION_ALIAS)_PASSWORD","title":"Database connections"},{"location":"environment%20configuration/#dominus-services","text":"Key Default value Description SERVICES_HTTP_CONNECTION_TIMEOUT 30 Maximum number of seconds that the connection can stay open (execution time) SERVICES_HTTP_CONNECT_TIMEOUT 30 The number of seconds to wait while trying to connect. Use 0 to wait indefinitely. SERVICES_HTTP_USERAGENT Dominus API SERVICES_HTTP_SSL_VERIFY_HOST true SERVICES_HTTP_SSL_VERIFY_PEER true","title":"Dominus Services"},{"location":"middleware/","text":"Middleware Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. Your middleware should resides in the App/Middleware directory of a dominus project. Defining Middleware We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { public function handle ( Request $request ) : MiddlewareResolution { if ( $request -> getParam ( 'token' ) !== 'valid-token' ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } return $this -> next (); } } We can now use middleware on our controller using the #[Middleware] attribute. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } See also Dependency Injection Services","title":"Middleware"},{"location":"middleware/#middleware","text":"Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. Your middleware should resides in the App/Middleware directory of a dominus project.","title":"Middleware"},{"location":"middleware/#defining-middleware","text":"We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace App / Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { public function handle ( Request $request ) : MiddlewareResolution { if ( $request -> getParam ( 'token' ) !== 'valid-token' ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } return $this -> next (); } } We can now use middleware on our controller using the #[Middleware] attribute. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Defining Middleware"},{"location":"middleware/#see-also","text":"Dependency Injection Services","title":"See also"},{"location":"models/","text":"Data models You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[Optional] public string $optionalProp = '' ; } Model attributes Optional Used to mark model properties as optional, when handling requests using data models. The framework will try and find each property name in the Request object, and will throw an Exception if the property is not found and not marked as optional. InitModel Used to declare any method inside a model to be used for initialization. This method will be called immediately after the Request object data has been mapped to the model properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; use Dominus\\System\\Attributes\\InitModel ; #[InitModel('init')] class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[Optional] public string $optionalProp = '' ; public function init () { // this method will be called immediately after the properties have been // mapped from the Request object } } See also Handling Requests","title":"Data models"},{"location":"models/#data-models","text":"You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[Optional] public string $optionalProp = '' ; }","title":"Data models"},{"location":"models/#model-attributes","text":"","title":"Model attributes"},{"location":"models/#optional","text":"Used to mark model properties as optional, when handling requests using data models. The framework will try and find each property name in the Request object, and will throw an Exception if the property is not found and not marked as optional.","title":"Optional"},{"location":"models/#initmodel","text":"Used to declare any method inside a model to be used for initialization. This method will be called immediately after the Request object data has been mapped to the model properties. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace App\\Modules\\MyModule\\Models ; use Dominus\\System\\Attributes\\Optional ; use Dominus\\System\\Attributes\\InitModel ; #[InitModel('init')] class MyDataModel { public int $prop1 = 0 ; public string $prop2 = '' ; #[Optional] public string $optionalProp = '' ; public function init () { // this method will be called immediately after the properties have been // mapped from the Request object } }","title":"InitModel"},{"location":"models/#see-also","text":"Handling Requests","title":"See also"},{"location":"modules/","text":"Modules Dominus applications are modular, these modules are containers for Controllers, Models, and everything else related to a particular module. Modules reside in the App/Modules directory of a dominus project. You can generate modules with the command generate module MyModule See also Controllers","title":"Modules"},{"location":"modules/#modules","text":"Dominus applications are modular, these modules are containers for Controllers, Models, and everything else related to a particular module. Modules reside in the App/Modules directory of a dominus project. You can generate modules with the command generate module MyModule","title":"Modules"},{"location":"modules/#see-also","text":"Controllers","title":"See also"},{"location":"repositories/","text":"Repository pattern The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } } See also Dependency Injection","title":"Repository pattern"},{"location":"repositories/#repository-pattern","text":"The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } }","title":"Repository pattern"},{"location":"repositories/#see-also","text":"Dependency Injection","title":"See also"},{"location":"request/","text":"Request The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application. Usage To access the request object, inject the in your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\TodoList\\Controllers ; class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } } Using data models to handle requests Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use App\\Modules\\TodoList\\Models\\FormDataModel ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\Optional ; class FormDataModel { public int $id = 0 ; public string $description = '' ; public DateTime | null $completedOn = null ; #[Optional] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. Even tough the automatic validation ensures that the request data respects the structure and data types of the given model, it does not however ensure that the data is correct, hence additional validation by the developer is still required. See also Data validation","title":"Request"},{"location":"request/#request","text":"The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application.","title":"Request"},{"location":"request/#usage","text":"To access the request object, inject the in your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace App\\Modules\\TodoList\\Controllers ; class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } }","title":"Usage"},{"location":"request/#using-data-models-to-handle-requests","text":"Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use App\\Modules\\TodoList\\Models\\FormDataModel ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace App\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\Optional ; class FormDataModel { public int $id = 0 ; public string $description = '' ; public DateTime | null $completedOn = null ; #[Optional] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. Even tough the automatic validation ensures that the request data respects the structure and data types of the given model, it does not however ensure that the data is correct, hence additional validation by the developer is still required.","title":"Using data models to handle requests"},{"location":"request/#see-also","text":"Data validation","title":"See also"},{"location":"routing/","text":"Routing Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/App/Modules/Mymodule/Controllers/MyController Basic route 1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase Route Shortcuts Module has the same name as the controller If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module Controller has an Entrypoint attribute set If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller See also Modules Controllers","title":"Routing"},{"location":"routing/#routing","text":"Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/App/Modules/Mymodule/Controllers/MyController","title":"Routing"},{"location":"routing/#basic-route","text":"1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase","title":"Basic route"},{"location":"routing/#route-shortcuts","text":"","title":"Route Shortcuts"},{"location":"routing/#module-has-the-same-name-as-the-controller","text":"If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module","title":"Module has the same name as the controller"},{"location":"routing/#controller-has-an-entrypoint-attribute-set","text":"If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller","title":"Controller has an Entrypoint attribute set"},{"location":"routing/#see-also","text":"Modules Controllers","title":"See also"},{"location":"services/","text":"Services A service in Dominus is really any class that implements the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. Your services should reside in the App/Services directory of a Dominus project. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace Dominus\\Services ; use Dominus\\System\\Interfaces\\Injectable\\Injectable ; class MyServiceService implements Injectable { public function __construct () { } } See also Dependency Injection Middleware","title":"Services"},{"location":"services/#services","text":"A service in Dominus is really any class that implements the Dominus\\System\\Interfaces\\Injectable\\Injectable interface. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. Your services should reside in the App/Services directory of a Dominus project. 1 2 3 4 5 6 7 8 9 10 11 12 <?php namespace Dominus\\Services ; use Dominus\\System\\Interfaces\\Injectable\\Injectable ; class MyServiceService implements Injectable { public function __construct () { } }","title":"Services"},{"location":"services/#see-also","text":"Dependency Injection Middleware","title":"See also"},{"location":"unit%20testing/","text":"Unit testing Dominus comes with its own little testing framework, which can be used to run simple unit tests. You can generate tests easily using the dominus cli with the command generate test MyTest . To create a unit test we begin by creating a new Test suite class in the Tests directory of a Dominus project, you can also create any number of subdirectories if you want to group your test suites further and the framework will scan for them recursively. Make sure your filename is the same as your class name! Our test suite class must extend the Dominus\\System\\Tests\\DominusTest base class. 1 2 3 4 5 6 7 8 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; class MyTest extends DominusTest { } We will use the Dominus\\System\\Attributes\\TestDescription attribute to name our test suite something accordingly. 1 2 3 4 5 6 7 8 9 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; #[TestDescription('My test description')] class MyTest extends DominusTest { } Now, we can create our individual test cases. We can set a description to our test cases using the same Dominus\\System\\Attributes\\TestDescription attribute that we used to describe our test suite. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestDescription ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[TestDescription('My test description')] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[TestRequestParameters([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[TestDescription('My test case 1')] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } Finally, we need to return the test instance so that the test framework can use it; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestDescription ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[TestDescription('My test description')] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[TestRequestParameters([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[TestDescription('My test case 1')] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } return new MyTest (); Now all that remains is to actually run our tests, to do this you can execute the run_tests.php file in the Dominus project root.","title":"Unit testing"},{"location":"unit%20testing/#unit-testing","text":"Dominus comes with its own little testing framework, which can be used to run simple unit tests. You can generate tests easily using the dominus cli with the command generate test MyTest . To create a unit test we begin by creating a new Test suite class in the Tests directory of a Dominus project, you can also create any number of subdirectories if you want to group your test suites further and the framework will scan for them recursively. Make sure your filename is the same as your class name! Our test suite class must extend the Dominus\\System\\Tests\\DominusTest base class. 1 2 3 4 5 6 7 8 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; class MyTest extends DominusTest { } We will use the Dominus\\System\\Attributes\\TestDescription attribute to name our test suite something accordingly. 1 2 3 4 5 6 7 8 9 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; #[TestDescription('My test description')] class MyTest extends DominusTest { } Now, we can create our individual test cases. We can set a description to our test cases using the same Dominus\\System\\Attributes\\TestDescription attribute that we used to describe our test suite. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestDescription ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[TestDescription('My test description')] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[TestRequestParameters([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[TestDescription('My test case 1')] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } Finally, we need to return the test instance so that the test framework can use it; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <?php namespace Tests ; use Dominus\\System\\Tests\\DominusTest ; use Dominus\\System\\Attributes\\TestDescription ; use Dominus\\System\\Attributes\\TestRequestParameters ; use Dominus\\System\\Exceptions\\TestFailedAssertionException ; use Dominus\\System\\Request ; #[TestDescription('My test description')] class MyTest extends DominusTest { /** * @throws TestFailedAssertionException */ #[TestRequestParameters([ 'myParameter' => 'value' , // parameters set here will be used to populate the Request object ])] #[TestDescription('My test case 1')] public function test_case_1 ( Request $request ) { $this -> assert ( $request -> get ( 'myParameter' ) === 'value' ); } } return new MyTest (); Now all that remains is to actually run our tests, to do this you can execute the run_tests.php file in the Dominus project root.","title":"Unit testing"},{"location":"validation/","text":"Data Validation Incoming data is always automatically validated based on the endpoint parameters if any. Auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer. Take the following controller code that handles logic for a simple todo app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } public function add () { ... } } To validate our todo entries, we will use the Dominus\\Services\\Validator service to help us. We start by injecting the Dominus\\Services\\Validator service in our add method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $rules = [ 'field' => [ new ValidationRule ( 'rule1' , 'Message stored on error' ) ], 'field2' => [ new ValidationRule ( 'rule2|arg1|arg2' , 'Message stored on error' ), new ValidationRule ( 'rule3' , 'Message stored on error' ), ], ]; $valid = $validator -> validate ( $data , $rules ); Multiple rules on the same field are run in order and stop at the first rule that has an error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 <?php namespace App\\Modules\\TodoList\\Controllers ; use App\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function add ( FormDataModel $data , Validator $validator ) { $valid = $validator -> validate ( $data , [ 'completedOn' => [ new ValidationRule ( 'date' , 'WRONG DATE!' ), // we can even make our own custom validations by passing an anonymous function new ValidationRule ( Closure :: bind ( function ( $date ) { return $this -> customValidator ( $date ); }, $this ) , 'CUSTOM VALIDATOR FAIL' ) ], 'description' => [ new ValidationRule ( static function ( $description ) { return strlen ( $description ) < 100 ; }, 'Description too large!' )] ]); if ( $valid ) { // The todo entry is valid } } private function customValidator ( $date ) { $d = DateTime :: createFromFormat ( \"Y-m-d\" , $date ); return $d && $d <= new DateTime (); // check for dates in the future } } All validation errors are stored and can be retrieved using the getErrors method from the validator service. The errors are stored in an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $errors = $validator -> getErrors (); // Contents of $errors: //[ // 'field' => [ // \"rule 1 error\", // ... // \"rule n error\" // ], // ... // 'field n' => [...] //] The getErrors method also accepts an optional filter in order to get the errors for a specific field. Available rules Below is a list of all the available validation rules. Rule arguments are separated by the following character: | . min_length max_length in_list not_in_list true not_equals equals required email date date_not_past date_not_future min_length min_length|5 Verifies that the field value is greater than or equal to the given length. max_length max_length|120 Verifies that the field value is less than or equal to the given length. in_list in_list|<value1>, <value2>, <value3> Verifies that the field value is contained in the given list. not_in_list not_in_list|<value1>, <value2>, <value3> Verifies that the field value is not contained in the given list. true true Verifies that the field value has a true boolean value. equals equals|<static-value> Verifies that the field value equals the provided static value. not_equals not_equals|<static-value> Verifies that the field value does not equal the provided static value. email email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator. required required Verifies that the field exists and is not empty. date date|<date-format> Verifies that the date is valid under the DateTime class. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date|d-m-Y . date_not_past date_not_past|<date-format> Verifies that the date is valid under the DateTime class and is not in the past. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_past|d-m-Y . date_not_future date_not_future|<date-format> Verifies that the date is valid under the DateTime class and is not in the future. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_future|d-m-Y . See also Handling requests","title":"Data Validation"},{"location":"validation/#data-validation","text":"Incoming data is always automatically validated based on the endpoint parameters if any. Auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer. Take the following controller code that handles logic for a simple todo app: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <?php namespace App\\Modules\\TodoList\\Controllers ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } public function add () { ... } } To validate our todo entries, we will use the Dominus\\Services\\Validator service to help us. We start by injecting the Dominus\\Services\\Validator service in our add method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $rules = [ 'field' => [ new ValidationRule ( 'rule1' , 'Message stored on error' ) ], 'field2' => [ new ValidationRule ( 'rule2|arg1|arg2' , 'Message stored on error' ), new ValidationRule ( 'rule3' , 'Message stored on error' ), ], ]; $valid = $validator -> validate ( $data , $rules ); Multiple rules on the same field are run in order and stop at the first rule that has an error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 <?php namespace App\\Modules\\TodoList\\Controllers ; use App\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function add ( FormDataModel $data , Validator $validator ) { $valid = $validator -> validate ( $data , [ 'completedOn' => [ new ValidationRule ( 'date' , 'WRONG DATE!' ), // we can even make our own custom validations by passing an anonymous function new ValidationRule ( Closure :: bind ( function ( $date ) { return $this -> customValidator ( $date ); }, $this ) , 'CUSTOM VALIDATOR FAIL' ) ], 'description' => [ new ValidationRule ( static function ( $description ) { return strlen ( $description ) < 100 ; }, 'Description too large!' )] ]); if ( $valid ) { // The todo entry is valid } } private function customValidator ( $date ) { $d = DateTime :: createFromFormat ( \"Y-m-d\" , $date ); return $d && $d <= new DateTime (); // check for dates in the future } } All validation errors are stored and can be retrieved using the getErrors method from the validator service. The errors are stored in an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $errors = $validator -> getErrors (); // Contents of $errors: //[ // 'field' => [ // \"rule 1 error\", // ... // \"rule n error\" // ], // ... // 'field n' => [...] //] The getErrors method also accepts an optional filter in order to get the errors for a specific field.","title":"Data Validation"},{"location":"validation/#available-rules","text":"Below is a list of all the available validation rules. Rule arguments are separated by the following character: | . min_length max_length in_list not_in_list true not_equals equals required email date date_not_past date_not_future","title":"Available rules"},{"location":"validation/#min_length","text":"min_length|5 Verifies that the field value is greater than or equal to the given length.","title":"min_length"},{"location":"validation/#max_length","text":"max_length|120 Verifies that the field value is less than or equal to the given length.","title":"max_length"},{"location":"validation/#in_list","text":"in_list|<value1>, <value2>, <value3> Verifies that the field value is contained in the given list.","title":"in_list"},{"location":"validation/#not_in_list","text":"not_in_list|<value1>, <value2>, <value3> Verifies that the field value is not contained in the given list.","title":"not_in_list"},{"location":"validation/#true","text":"true Verifies that the field value has a true boolean value.","title":"true"},{"location":"validation/#equals","text":"equals|<static-value> Verifies that the field value equals the provided static value.","title":"equals"},{"location":"validation/#not_equals","text":"not_equals|<static-value> Verifies that the field value does not equal the provided static value.","title":"not_equals"},{"location":"validation/#email","text":"email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator.","title":"email"},{"location":"validation/#required","text":"required Verifies that the field exists and is not empty.","title":"required"},{"location":"validation/#date","text":"date|<date-format> Verifies that the date is valid under the DateTime class. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date|d-m-Y .","title":"date"},{"location":"validation/#date_not_past","text":"date_not_past|<date-format> Verifies that the date is valid under the DateTime class and is not in the past. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_past|d-m-Y .","title":"date_not_past"},{"location":"validation/#date_not_future","text":"date_not_future|<date-format> Verifies that the date is valid under the DateTime class and is not in the future. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_future|d-m-Y .","title":"date_not_future"},{"location":"validation/#see-also","text":"Handling requests","title":"See also"}]}