{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Installation You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. You are now ready to create your first modules. Directory Structure Root Directory Logs Middleware Modules Controllers Models Middleware Repositories Services Services System Logs Framework logs as well as php logs are stored here as .csv files with the current date (Y-m-d) as the filename. Middleware Application middleware created with the CLI will be stored here. Modules Your modules will be stored inside this directory. Services Framework services as well as those created with the CLI will be stored in this directory. System Framework system files are stored here and should not be modified.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"You can quickly create a Dominus api backends with the Dominus CLI . Before continuing, please make sure you have python and pip module installed on your machine, the CLI depends on them to function :). Start by cloning the CLI files from the main repository. 1 git clone https://github.com/daniel1919-00/DominusCli Access the CLI using the starter scripts: dominus.sh for Linux/macOS or dominus.bat for Windows. You may create a new project by changing the current directory to the desired path and using the new command. 1 new my-project After the project has been created, you can access it either by installing a web server yourself, or using the docker configuration (if prompted yes when asked by the cli) from the Dominus framework which includes nginx with php8.1 and xdebug installed. You are now ready to create your first modules.","title":"Installation"},{"location":"#directory-structure","text":"Root Directory Logs Middleware Modules Controllers Models Middleware Repositories Services Services System","title":"Directory Structure"},{"location":"#logs","text":"Framework logs as well as php logs are stored here as .csv files with the current date (Y-m-d) as the filename.","title":"Logs"},{"location":"#middleware","text":"Application middleware created with the CLI will be stored here.","title":"Middleware"},{"location":"#modules","text":"Your modules will be stored inside this directory.","title":"Modules"},{"location":"#services","text":"Framework services as well as those created with the CLI will be stored in this directory.","title":"Services"},{"location":"#system","text":"Framework system files are stored here and should not be modified.","title":"System"},{"location":"the%20basics/controllers/","text":"Controllers Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers are always stored in a module's Controllers directory. Basic Controllers A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } } Controller attributes There are several php attributes that we can use to enhance out controllers and methods. Entrypoint System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by default if none is provided in the request. RequestMethod System\\Attributes\\RequestMethod This attribute provides a convenient way to limit controller method access to a specific request method. Middleware System\\Attributes\\Middleware Middleware may be assigned to the controller class as a whole or on specific methods","title":"Controllers"},{"location":"the%20basics/controllers/#controllers","text":"Controllers group related request handling logic into a single class. For example a TodoController class might handle all requests related to a todo list. Controllers are always stored in a module's Controllers directory.","title":"Controllers"},{"location":"the%20basics/controllers/#basic-controllers","text":"A controller is a class that extends the Dominus System\\Controller base class. Let's take a look at a simple controller which we will generate using the Dominus CLI and use it to handle requests for a todo list application. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace Modules\\TodoList\\Controllers ; use System\\Controller ; use System\\Attributes\\Entrypoint ; use System\\Attributes\\RequestMethod ; #[Entrypoint('list')] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Basic Controllers"},{"location":"the%20basics/controllers/#controller-attributes","text":"There are several php attributes that we can use to enhance out controllers and methods.","title":"Controller attributes"},{"location":"the%20basics/controllers/#entrypoint","text":"System\\Attributes\\Entrypoint This attribute configures the router to access the method specified by default if none is provided in the request.","title":"Entrypoint"},{"location":"the%20basics/controllers/#requestmethod","text":"System\\Attributes\\RequestMethod This attribute provides a convenient way to limit controller method access to a specific request method.","title":"RequestMethod"},{"location":"the%20basics/controllers/#middleware","text":"System\\Attributes\\Middleware Middleware may be assigned to the controller class as a whole or on specific methods","title":"Middleware"},{"location":"the%20basics/middleware/","text":"Middleware Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application. Defining Middleware We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { public function handle ( Request $request ) : MiddlewareResolution { if ( $request -> getParam ( 'token' ) !== 'valid-token' ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } return $this -> next (); } } We can now use middleware on our controller using the #[Middleware] attribute. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Middleware"},{"location":"the%20basics/middleware/#middleware","text":"Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering your application.","title":"Middleware"},{"location":"the%20basics/middleware/#defining-middleware","text":"We can use the Dominus CLI to generate middleware with the following command: 1 generate middleware UserTokenValid We have created a UserTokenValidMiddleware middleware which we can then use to authenticate the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 <?php namespace Middleware ; use Dominus\\Services\\Http\\Models\\HttpStatus ; use Dominus\\Dominus\\System\\Middleware ; use Dominus\\Dominus\\System\\MiddlewareResolution ; use Dominus\\Dominus\\System\\Request ; class UserTokenValidMiddleware extends Middleware { public function handle ( Request $request ) : MiddlewareResolution { if ( $request -> getParam ( 'token' ) !== 'valid-token' ) { $this -> reject ( httpStatusCode : HttpStatus :: UNAUTHORIZED ); } return $this -> next (); } } We can now use middleware on our controller using the #[Middleware] attribute. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?php namespace Modules\\TodoList\\Controllers ; use Dominus\\Middleware\\UserTokenValidMiddleware ; use Dominus\\System\\Controller ; use Dominus\\System\\Attributes\\Entrypoint ; use Dominus\\System\\Attributes\\Middleware ; use Dominus\\System\\Attributes\\RequestMethod ; #[Entrypoint('list')] #[Middleware(UserTokenValidMiddleware::class)] class TodoListController extends Controller { #[RequestMethod('GET')] public function list () { return [ 'item 1' , 'item 2' , 'item 3' ]; } }","title":"Defining Middleware"},{"location":"the%20basics/models/","text":"Data models You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 <?php namespace Dominus\\Modules\\MyModule\\Models ; class MyDataModel { }","title":"Data models"},{"location":"the%20basics/models/#data-models","text":"You can create models using the Dominus CLI using the generate model command. It will automatically use the namespace of the current Module and create an empty class. 1 2 3 4 5 6 7 <?php namespace Dominus\\Modules\\MyModule\\Models ; class MyDataModel { }","title":"Data models"},{"location":"the%20basics/modules/","text":"Modules Dominus applications are modular, these modules are containers for all Controllers, Models, and everything else related to a particular module. You can generate modules with the command generate module MyModule","title":"Modules"},{"location":"the%20basics/modules/#modules","text":"Dominus applications are modular, these modules are containers for all Controllers, Models, and everything else related to a particular module. You can generate modules with the command generate module MyModule","title":"Modules"},{"location":"the%20basics/repositories/","text":"Repository pattern The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace Dominus\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } }","title":"Repository pattern"},{"location":"the%20basics/repositories/#repository-pattern","text":"The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create the data access logic in a separate class, or set of classes, called a repository with the responsibility of persisting the application's business model. You can generate repository classes using the Dominus CLI with the following command: generate repository MyRepository 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace Dominus\\Modules\\MyModule\\Repositories ; use Dominus\\System\\Repository ; final class MyRepositoryRepository extends Repository { // Example method // public function getItems(): array // { // $db = $this->getDb(); // return $db->prepare('SELECT item_name FROM items')->execute()->fetchAllFromColumn(); // } }","title":"Repository pattern"},{"location":"the%20basics/request/","text":"Request The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application. Usage To access the request object, inject the in your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 <?php class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } }","title":"Request"},{"location":"the%20basics/request/#request","text":"The request object is an abstraction of the current HTTP request and allows you to easily interact with any data passed into your application.","title":"Request"},{"location":"the%20basics/request/#usage","text":"To access the request object, inject the in your method or controller constructor. 1 2 3 4 5 6 7 8 9 10 <?php class TodoListController extends Controller { public function fetchItems ( Request $request , TodoRepository $repo ) : array { return $repo -> fetchItems ( $request -> get ( 'userId' ) ); } }","title":"Usage"},{"location":"the%20basics/routing/","text":"Routing Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/Modules/Mymodule/Controllers/MyController Basic route 1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase Route Shortcuts Module has the same name as the controller If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module Controller has an Entrypoint attribute set If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller","title":"Routing"},{"location":"the%20basics/routing/#routing","text":"Routing in Dominus is always the same no matter what! The route will always match the project directory structure: [ProjectRoot]/Modules/Mymodule/Controllers/MyController","title":"Routing"},{"location":"the%20basics/routing/#basic-route","text":"1 2 3 /MyModule/MyController/myMethod?param=value or /my-module/my-controller/my-method?param=value -- this will be converted automatically to camelCase","title":"Basic route"},{"location":"the%20basics/routing/#route-shortcuts","text":"","title":"Route Shortcuts"},{"location":"the%20basics/routing/#module-has-the-same-name-as-the-controller","text":"If your module and controller has the same name, then the url can be shortened like so 1 2 3 /MyModule or /my-module","title":"Module has the same name as the controller"},{"location":"the%20basics/routing/#controller-has-an-entrypoint-attribute-set","text":"If the controller has an Entrypoint set then the method can be omitted from the url 1 2 3 /MyModule/MyController or /my-module/my-controller","title":"Controller has an Entrypoint attribute set"},{"location":"the%20basics/services/","text":"Services A service in Dominus is really any class that extends the Dominus\\System\\Injectable class. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace Dominus\\Services ; use Dominus\\System\\Injectable ; class MyServiceService extends Injectable { /** * Use this method if this service needs special instantiation. Ex: being instantiated from a static method like DateTime::createFromFormat() * Note that dependency injection is not possible via this method * @return object the class instance to be injected */ // public static function _getInjectionInstance() // { // } public function __construct () { } }","title":"Services"},{"location":"the%20basics/services/#services","text":"A service in Dominus is really any class that extends the Dominus\\System\\Injectable class. These Injectable classes can then be constructed and injected in any Controller constructor or method that requires it. They can also be injected into other services as well. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php namespace Dominus\\Services ; use Dominus\\System\\Injectable ; class MyServiceService extends Injectable { /** * Use this method if this service needs special instantiation. Ex: being instantiated from a static method like DateTime::createFromFormat() * Note that dependency injection is not possible via this method * @return object the class instance to be injected */ // public static function _getInjectionInstance() // { // } public function __construct () { } }","title":"Services"},{"location":"the%20basics/validation/","text":"Request Validation Incoming data is always automatically validated based on the endpoint parameters if any. Of course auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer. Auto-validation Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace Dominus\\Modules\\TodoList\\Controllers ; use Dominus\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace Dominus\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\Optional ; class FormDataModel { public int $id = 0 ; public string $description = '' ; public DateTime | null $completedOn = null ; #[Optional] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. Even tough the automatic validation ensures that the request data respects the structure and data types of the given model, it does not however ensure that the data is correct, hence additional validation by the developer is still required. Developer Validation We will take the previous controller example and write some validation logic for our todo entry. We start by injecting the Dominus\\Services\\Validator service in our store method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $rules = [ 'field' => [ new ValidationRule ( 'rule1' , 'Message stored on error' ) ], 'field2' => [ new ValidationRule ( 'rule2|arg1|arg2' , 'Message stored on error' ), new ValidationRule ( 'rule3' , 'Message stored on error' ), ], ]; $valid = $validator -> validate ( $data , $rules ); Multiple rules on the same field are run in order and stop at the first rule that has an error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 <?php namespace Dominus\\Modules\\TodoList\\Controllers ; use Dominus\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function store ( FormDataModel $data , Validator $validator ) { $valid = $validator -> validate ( $data , [ 'completedOn' => [ new ValidationRule ( 'date' , 'WRONG DATE!' ), // we can even make our own custom validations by passing an anonymous function new ValidationRule ( Closure :: bind ( function ( $date ) { return $this -> customValidator ( $date ); }, $this ) , 'CUSTOM VALIDATOR FAIL' ) ], 'description' => [ new ValidationRule ( static function ( $description ) { return strlen ( $description ) < 100 ; }, 'Description too large!' )] ]); if ( $valid ) { // The todo entry is valid } } private function customValidator ( $date ) { $d = DateTime :: createFromFormat ( \"Y-m-d\" , $date ); return $d && $d <= new DateTime (); // check for dates in the future } } All validation errors are stored and can be retrieved using the getErrors method from the validator service. The errors are stored in an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $errors = $validator -> getErrors (); // Contents of $errors: //[ // 'field' => [ // \"rule 1 error\", // ... // \"rule n error\" // ], // ... // 'field n' => [...] //] The getErrors method also accepts an optional filter in order to get the errors for a specific field. Available rules Below is a list of all the available validation rules. Rule arguments are separated by the following character: | . min_length max_length in_list not_in_list true not_equals equals required email date date_not_past date_not_future min_length min_length|5 Verifies that the field value is greater than or equal to the given length. max_length max_length|120 Verifies that the field value is less than or equal to the given length. in_list in_list|<value1>, <value2>, <value3> Verifies that the field value is contained in the given list. not_in_list not_in_list|<value1>, <value2>, <value3> Verifies that the field value is not contained in the given list. true true Verifies that the field value has a true boolean value. equals equals|<static-value> Verifies that the field value equals the provided static value. not_equals not_equals|<static-value> Verifies that the field value does not equal the provided static value. email email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator. required required Verifies that the field exists and is not empty. date date|<date-format> Verifies that the date is valid under the DateTime class. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date|d-m-Y . date_not_past date_not_past|<date-format> Verifies that the date is valid under the DateTime class and is not in the past. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_past|d-m-Y . date_not_future date_not_future|<date-format> Verifies that the date is valid under the DateTime class and is not in the future. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_future|d-m-Y .","title":"Request Validation"},{"location":"the%20basics/validation/#request-validation","text":"Incoming data is always automatically validated based on the endpoint parameters if any. Of course auto-validation only ensures that the request matches the desired model structure, if the data itself is valid or not still needs to be validated by the developer.","title":"Request Validation"},{"location":"the%20basics/validation/#auto-validation","text":"Take the following controller: 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php namespace Dominus\\Modules\\TodoList\\Controllers ; use Dominus\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; class TodoListController extends Controller { public function store ( FormDataModel $data ) { } } The automatic validation ensures that the data entered the application respects the required data model (if it is provided). Let's take a look at the model used in the previous example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?php namespace Dominus\\Modules\\TodoList\\Models ; use Dominus\\System\\Attributes\\Optional ; class FormDataModel { public int $id = 0 ; public string $description = '' ; public DateTime | null $completedOn = null ; #[Optional] public string $optionalDetails ; } Notice the #[Optional] property decorator which specifies that it is ok if the incoming request does not contain this property. Even tough the automatic validation ensures that the request data respects the structure and data types of the given model, it does not however ensure that the data is correct, hence additional validation by the developer is still required.","title":"Auto-validation"},{"location":"the%20basics/validation/#developer-validation","text":"We will take the previous controller example and write some validation logic for our todo entry. We start by injecting the Dominus\\Services\\Validator service in our store method, then use the validate method to validate the data using the given rules . The validate method accepts an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $rules = [ 'field' => [ new ValidationRule ( 'rule1' , 'Message stored on error' ) ], 'field2' => [ new ValidationRule ( 'rule2|arg1|arg2' , 'Message stored on error' ), new ValidationRule ( 'rule3' , 'Message stored on error' ), ], ]; $valid = $validator -> validate ( $data , $rules ); Multiple rules on the same field are run in order and stop at the first rule that has an error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 <?php namespace Dominus\\Modules\\TodoList\\Controllers ; use Dominus\\Modules\\TodoList\\Models\\FormDataModel ; use Dominus\\System\\Controller ; use Dominus\\Services\\Validator ; class TodoListController extends Controller { public function store ( FormDataModel $data , Validator $validator ) { $valid = $validator -> validate ( $data , [ 'completedOn' => [ new ValidationRule ( 'date' , 'WRONG DATE!' ), // we can even make our own custom validations by passing an anonymous function new ValidationRule ( Closure :: bind ( function ( $date ) { return $this -> customValidator ( $date ); }, $this ) , 'CUSTOM VALIDATOR FAIL' ) ], 'description' => [ new ValidationRule ( static function ( $description ) { return strlen ( $description ) < 100 ; }, 'Description too large!' )] ]); if ( $valid ) { // The todo entry is valid } } private function customValidator ( $date ) { $d = DateTime :: createFromFormat ( \"Y-m-d\" , $date ); return $d && $d <= new DateTime (); // check for dates in the future } } All validation errors are stored and can be retrieved using the getErrors method from the validator service. The errors are stored in an array of the form: 1 2 3 4 5 6 7 8 9 10 11 12 <?php $errors = $validator -> getErrors (); // Contents of $errors: //[ // 'field' => [ // \"rule 1 error\", // ... // \"rule n error\" // ], // ... // 'field n' => [...] //] The getErrors method also accepts an optional filter in order to get the errors for a specific field.","title":"Developer Validation"},{"location":"the%20basics/validation/#available-rules","text":"Below is a list of all the available validation rules. Rule arguments are separated by the following character: | . min_length max_length in_list not_in_list true not_equals equals required email date date_not_past date_not_future","title":"Available rules"},{"location":"the%20basics/validation/#min_length","text":"min_length|5 Verifies that the field value is greater than or equal to the given length.","title":"min_length"},{"location":"the%20basics/validation/#max_length","text":"max_length|120 Verifies that the field value is less than or equal to the given length.","title":"max_length"},{"location":"the%20basics/validation/#in_list","text":"in_list|<value1>, <value2>, <value3> Verifies that the field value is contained in the given list.","title":"in_list"},{"location":"the%20basics/validation/#not_in_list","text":"not_in_list|<value1>, <value2>, <value3> Verifies that the field value is not contained in the given list.","title":"not_in_list"},{"location":"the%20basics/validation/#true","text":"true Verifies that the field value has a true boolean value.","title":"true"},{"location":"the%20basics/validation/#equals","text":"equals|<static-value> Verifies that the field value equals the provided static value.","title":"equals"},{"location":"the%20basics/validation/#not_equals","text":"not_equals|<static-value> Verifies that the field value does not equal the provided static value.","title":"not_equals"},{"location":"the%20basics/validation/#email","text":"email Verifies if the email is well formatted, uses php's filter_var function. If you need more advanced validation, you may want to use a custom validator.","title":"email"},{"location":"the%20basics/validation/#required","text":"required Verifies that the field exists and is not empty.","title":"required"},{"location":"the%20basics/validation/#date","text":"date|<date-format> Verifies that the date is valid under the DateTime class. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date|d-m-Y .","title":"date"},{"location":"the%20basics/validation/#date_not_past","text":"date_not_past|<date-format> Verifies that the date is valid under the DateTime class and is not in the past. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_past|d-m-Y .","title":"date_not_past"},{"location":"the%20basics/validation/#date_not_future","text":"date_not_future|<date-format> Verifies that the date is valid under the DateTime class and is not in the future. By default, the Y-m-d date format is assumed. You can change the parsed format by passing it along with the rule like so: date_not_future|d-m-Y .","title":"date_not_future"}]}